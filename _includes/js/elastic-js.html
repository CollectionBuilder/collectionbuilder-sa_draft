{%- assign fields = site.data.config-search -%}
<script>

const ES_SEARCH_URL = "http://{{ site.elasticsearch-host }}/{{ site.elasticsearch-index }}/_search"

async function doSearch (q) {
  /* Perform the search and return the response, or return null if something
   goes wrong (e.g. server not reachable, response not JSON, etc.)
   */
  let query

  // Build the basic query.
  if (q === "") {
    // Do a match_all query.
    query = {
      query: {
        match_all: {}
      }
    }
  } else {
    // Do a phrase_prefix query.
    query = {
      query: {
        multi_match: {
          query: q,
          type: "phrase_prefix",
          fields: [
            {% assign indexed = fields | where: 'index','true' %}
            {% for f in indexed %}
            "{{ f.field }}",
            {% endfor %}
            "full_text.raw",
          ]
        }
      }
    }
  }

  // Add any aggregations.
  {% assign faceted = fields | where: 'facet','true' %}
  query.aggs = {
    {% for f in faceted %}
    {{ f.field }}: {
      terms: {
        field: "{{ f.field }}"
      }
    },
    {% endfor %}
  }

  // Specify which document fields we want returned.
  query._source = [
    "objectid",
    {% for f in fields %}
    "{{ f.field }}",
    {% endfor %}
  ]

  let fetchRespons
  try {
    fetchResponse = await fetch(
      ES_SEARCH_URL,
      {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(query)
      }
    )
  } catch (e) {
    return null
  }

  let searchResponse
  // If the content is not JSON, abort, otherwise attempt to decode it.
  if (!fetchResponse.headers.get('Content-Type')
      .startsWith('application/json')) {
    return null
  } else {
    try {
      searchResponse = await fetchResponse.json()
    } catch (e) {
      return null
    }
  }

  if (!fetchResponse.ok) {
    // If it looks like an ES error, print the 'reason' to the console.
    if (searchResponse.error && searchResponse.error.reason) {
      console.error(`Search error: ${searchResponse.error.reason}`)
    }
    return null
  }

  return searchResponse
}


// Convert the facet name to a title.
const facetNameToTitle = s =>
  s.replace('_', ' ')
  .replace(/\b[a-z]/g, (x) => x.toUpperCase())

// Return the facet row HTML.
const FacetRowEl = (name, value, docCount) => $(`
  <div style="white-space: nowrap; color: #444; padding: .1em .5em; border-bottom: solid #eee 1px; position: relative; cursor: pointer;" data-facet="${name}" data-value="${value}">
    <span style="white-space: nowrap; margin-right: 2em;">
      ${value.length ? value : '&lt;unknown&gt;'}
    </span>
    <span style="position: absolute; right: 1em;">${docCount}</span>
  </div>
`)


// Return the facet element.
const DEFAULT_NUM_VISIBLE_FACETS = 5

function FacetEl (facet, buckets) {
  const facetEl = $(`
    <div style="font-size: .8em; border: solid #ddd 1px; margin-bottom: 2em;">
      <h1 style="font-size: inherit; background-color: #ddd; padding: .3em; font-weight: bold; margin-bottom: 0; cursor: pointer; white-space: nowrap; padding-right: 5em; position: relative;">
        ${facetNameToTitle(facet)}
        <span style="position: absolute; right: 1em; font-weight: bold; color: #666; font-family: monospace; font-size: 1.4em;">+</span>
      </h1>
    </div>
  `)

  // Add and collect the value rows.
  let rowEls = []
  buckets.forEach((bucket, i) => {
    let rowEl = FacetRowEl(facet, bucket.key, bucket.doc_count)
    rowEls.push(rowEl)
    facetEl.append(rowEl)
  })

  // Define "N more" / "show fewer" click handler.
  const showMoreStr = `show ${rowEls.length - DEFAULT_NUM_VISIBLE_FACETS} more`
  let moreOrFewer = "more"
  const showMoreClickHandler = e => {
    const showMore = moreOrFewer === "more"
    rowEls
      .slice(DEFAULT_NUM_VISIBLE_FACETS)
      .forEach(el => el.css("display", showMore ? "block" : "none"))
    e.target.innerText = showMore ? "show fewer" : showMoreStr
    moreOrFewer = showMore ? "fewer" : "more"
  }

  // Hide rows and append "show N more" as necessary.
  let moreOrFewerEl
  if (rowEls.length > DEFAULT_NUM_VISIBLE_FACETS) {
    rowEls
      .slice(DEFAULT_NUM_VISIBLE_FACETS)
      .forEach(el => el.css("display", "none"))
    moreOrFewerEl = $(`
      <div style="text-align: center; font-size: .9em; background-color: #f8f8f8; color: #888; cursor: pointer;">
        ${showMoreStr}
      </div>
    `)
    moreOrFewerEl.on('click', showMoreClickHandler)
    facetEl.append(moreOrFewerEl)
  }

  // Determine whether the facet should be considered collapsed.
  let collapsed = rowEls.length > DEFAULT_NUM_VISIBLE_FACETS ? null : false

  // Set the header +/- icon based on the collapsed state.
  const collapsedIconEl = $('h1 > span', facetEl)
  collapsedIconEl.html(collapsed === false ? '-' : '+')

  // Define header click handler.
  const headerClickHandler = e => {
    if (collapsed === null) {
      // The action of this first click is determined by the current
      // value of moreOrFewer.
      collapsed = moreOrFewer === "more"
    }
    if (moreOrFewerEl !== undefined) {
      moreOrFewerEl.remove()
      moreOrFewerEl = undefined
    }
    rowEls.forEach(el => el.css("display", collapsed ? "block" : "none"))
    collapsed = !collapsed
    // Toggle the header collapsed icon.
    collapsedIconEl.html(collapsed ? '+' : '-')
  }

  // Attach the click handler to the <h1>.
  $('h1', facetEl).on('click', headerClickHandler)


  return facetEl
}


function renderFacets (aggregations) {
  const facetsEl = $('#facets')
  facetsEl.empty()

  const facets = [{% for f in faceted %}"{{ f.field }}",{% endfor %}]
  let facetEl
  for (let facet of facets) {
    if (!aggregations[facet]) {
      continue
    }
    facetsEl.append(FacetEl(facet, aggregations[facet].buckets))
  }
}


/* search function */
async function elastic_search (searchParams) {
  const query = searchParams.get('q')
  var resultdiv = $('#results');

  resultdiv.empty();

  const response = await doSearch(query)
  if (response === null) {
    resultdiv.append('Search failed. Please contact your administrator.')
    return
  }

  renderFacets(response.aggregations)

  resultdiv.prepend('<tr><td><h4 class="mt-3">' + response.hits.total.value + ' Result(s) found</h4></td></tr>');
  for (let hit of response.hits.hits) {
    const item = hit._source
    var searchitem =
      '<tr>'+
          '<td class="">' +
            {% assign display = fields | where: 'display','true' %}
            {% for d in display %}
            {% if forloop.first %}
            '<p class="h4"><a href="{{ "/items/" | relative_url }}' + item.objectid + '.html">' + item.{{ fields[0].field }}  + '</a></p>' +
            '<p class="ml-3">' +
              {% else %}
              item.{{ d.field }} + '<br> ' +
              {% endif %}{% endfor %}
            '</p></td>' +
      '</tr>';
    resultdiv.append(searchitem);
  }
}


function facetsClickHandler (e) {
  const target = e.target.parentElement
  if (!target.dataset.hasOwnProperty('facet')) {
    return
  }

  const facetName = target.dataset.facet
  const facetValue = target.dataset.value
  const params = new URLSearchParams(location.search)
  const paramKey = `${facetName}[]`
  let paramVals = params.getAll(paramKey)

  if (paramVals.includes(paramKey)) {
    paramVals.pop(facetValue)
  } else {
    paramVals.push(facetValue)
  }
  params.delete(paramKey)
  paramVals.forEach(v => params.append(paramKey, v))
  location.search = `?${params.toString()}`
}


/* init search box and get query string */
$(document).ready(function() {
  // Register the facets click handler.
  $('#facets').on('click', facetsClickHandler)

  $('input#search').on('keyup', e => {
    elastic_search(e.target.value)
  })

  if (window.location.search) {
    const searchParams = new URLSearchParams(location.search)
    const queryString = searchParams.get('q')
    $('input#search').val(queryString);
    elastic_search(searchParams);
  }
});
</script>
