{%- assign fields = site.data.config-search -%}
{%- assign facetFields = fields | where: "facet","true" -%}
{%- assign displayFields = fields | where: "display","true" -%}

<script type="module">
 import SearchFacets from "/assets/js/components/SearchFacets.js"

 import "/assets/js/components/SearchFacet.js"
 import "/assets/js/components/SearchFacetValues.js"
 import "/assets/js/components/SearchFacetValue.js"

 import { TOPICS, subscribe } from "/assets/js/pubSub.js"
 import {
   createElement,
   snakeToTitleCase,
   clone,
   removeChildren,
   getUrlSearchParams,
   updateUrlSearchParams,
 } from "/assets/js/helpers.js"


 // Inject the search config data from the liquid template
 // into javascript variables.
 const ALL_FIELD_NAMES = [
   {%- for f in fields -%}
   "{{ f.field }}",
   {%- endfor -%}
 ]

 const FACETED_FIELD_NAMES = [
   {%- for f in facetFields -%}
   "{{ f.field }}",
   {%- endfor -%}
 ]

 const DISPLAY_FIELD_NAMES = [
   {%- for f in displayFields -%}
   "{{ f.field }}",
   {%- endfor -%}
 ]

 const INDEX_NAME = "{{ site.elasticsearch-index }}"
 const ES_SEARCH_URL_TEMPLATE = indices => `{{ site.elasticsearch-protocol }}://{{ site.elasticsearch-host }}:{{ site.elasticsearch-port }}/${indices.join(",")}/_search`
 const ES_DIRECTORY_URL = "{{ site.elasticsearch-protocol }}://{{ site.elasticsearch-host }}:{{ site.elasticsearch-port }}/directory_/_search"

 // Define the maximum number of facet values to show by default.
 const MAX_NUM_VISIBLE_FACET_VALUES = 5

 // Define the maximum number of facet values to show when the user clicks
 // "show more".
 const MAX_NUM_FACET_VALUES = 25

 // Define the default search results page size.
 const DEFAULT_NUM_RESULTS = 10

 // Define a flag that indicates whether this is the multi-search page,
 // as opposed to the collection-specific page.
 const IS_MULTI_SEARCH = "{{ page.layout }}" === "multi-collection-search"

 // Define global variables to store the ES server indices_directory info.
 let indicesDirectory
 const indicesDirectoryTitleIndexMap = new Map()
 const indicesDirectoryIndexTitleMap = new Map()


 async function getIndicesDirectory () {
   /* Attempt to retrieve the indices directory from the server.
    */
   const res = await (await fetch(ES_DIRECTORY_URL))
   if (res.status === 200) {
     return (await res.json())
       .hits
       .hits
       .map( x => x['_source'] )
   }
   console.error("Unable to retrieve the indices directory from the Elasticsearch server")
   return null
 }


 function generateSearchQuery (searchParams) {
   // Extract any start and size paging params from searchParams.
   let startParam = 0
   if (searchParams.has("start")) {
     startParam = parseInt(searchParams.get("start"))
     searchParams.delete("start")
   }

   let sizeParam = DEFAULT_NUM_RESULTS
   if (searchParams.has("size")) {
     sizeParam = parseInt(searchParams.get("size"))
     searchParams.delete("size")
   }


   // Init the query context to a match_all.
   let queryContext = { match_all: {} }

   // Add a full text query.
   const q = searchParams.get("q")
   if (q) {
     queryContext = {
       simple_query_string: {
         query: q,
         default_operator: "and",
         fields: searchParams.get("fields") || ["*"]
       }
     }
   }

   // Set the array of indices to search against.
   let indiceTitles
   if (!IS_MULTI_SEARCH) {
     indiceTitles = [ "{{ site.title }}" ]
   } else {
     indiceTitles = searchParams.get("collection[]")
     if (!indiceTitles) {
       // Search all collections if none is specified.
       indiceTitles = Array.from(indicesDirectoryTitleIndexMap.keys())
     } else {
       // Delete collection[] from the searchParams to prevent
       // it being specified as filter.
       searchParams.delete("collection[]")
     }
   }
   const indices = indiceTitles.map(x => indicesDirectoryTitleIndexMap.get(x))

   // Build the filter context.
   let filterContext = []
   for (let [k, v] of searchParams.entries()) {
     if (k === "q" || k === "fields") {
       continue
     }
     // Add a term filter.
     const isArray = k.endsWith("[]")
     let fieldName = `${isArray ? k.slice(0, k.length - 2) : k}.raw`
     let fieldValues = isArray ? v : [v]
     fieldValues.forEach(fieldValue => {
       filterContext.push({
         term: { [fieldName]: fieldValue }
       })
     })
   }

   let query = {
     from: startParam,
     size: sizeParam,
     query: {}
   }

   if (filterContext.length === 0) {
     // Build non-filtered query.
     query.query = queryContext
   } else {
     // Build filtered query.
     query.query = {
       bool: {
         must: queryContext,
         filter: filterContext
       }
     }
   }

   // Add any aggregations.
   query.aggs = {}
   for (let fieldName of FACETED_FIELD_NAMES) {
     query.aggs[fieldName] = {
       terms: {
         field: `${fieldName}.raw`,
         // Size defines the maximum number of buckets to return.
         size: MAX_NUM_FACET_VALUES
       }
     }
   }

   // Specify which document fields we want returned.
   query._source = [
     "objectid",
     "url",
     "thumbnailContentUrl",
     "collectionTitle",
     "collectionUrl",
   ].concat(ALL_FIELD_NAMES)

   // Define an object to represent the paging state.
   const paging = {
     start: startParam,
     size: sizeParam,
   }

   return [ indices, paging, query ]
 }


 async function executeQuery (indices, query) {
   /* Perform the search and return the response, or return null if something
      goes wrong (e.g. server not reachable, response not JSON, etc.)
    */
   let fetchResponse
   try {
     fetchResponse = await fetch(
       ES_SEARCH_URL_TEMPLATE(indices),
       {
         method: "POST",
         headers: {
           "Accept": "application/json",
           "Content-Type": "application/json"
         },
         body: JSON.stringify(query)
       }
     )
   } catch (e) {
     return null
   }

   let data
   // If the content is not JSON, abort, otherwise attempt to decode it.
   if (!fetchResponse.headers.get("Content-Type")
                     .startsWith("application/json")) {
     return null
   } else {
     try {
       data = await fetchResponse.json()
     } catch (e) {
       return null
     }
   }

   if (!fetchResponse.ok) {
     // If it looks like an ES error, print the 'reason' to the console.
     if (data.error && data.error.reason) {
       console.error(`Search error: ${data.error.reason}`)
     }
     return null
   }

   return data
 }


 async function executeSearch (searchParams) {
   /* Execute a search and all-indices count for the given URL search params.
    */
   const [ searchIndices, paging, searchQuery ] = generateSearchQuery(searchParams)
   const allIndices = Array.from(indicesDirectoryIndexTitleMap.keys())

   // Create a count query that counts hits across all indices and returns
   // no documents.
   const countQuery = {
     size: 0,
     query: searchQuery.query,
     aggs: {
       collection: {
         terms: {
           field: "_index",
           size: allIndices.length
         }
       }
     }
   }

   const [ searchResponse, countResponse ] = await Promise.all([
     executeQuery(searchIndices, searchQuery),
     executeQuery(allIndices, countQuery),
   ])

   // Augment the search response with the count response collection aggregation.
   const collectionAgg = countResponse.aggregations.collection
   // Add zero-count buckets for any unrepresented indices.
   const representedIndices = collectionAgg.buckets.map(({ key }) => key)
   for (const indice of allIndices.filter(x => !representedIndices.includes(x))) {
     collectionAgg.buckets.push({ key: indice, doc_count: 0 })
   }
   // Swap the indice names with their titles.
   for (const bucket of collectionAgg.buckets) {
     bucket.key = indicesDirectoryIndexTitleMap.get(bucket.key)
   }
   searchResponse.aggregations.collection = collectionAgg

   return [ paging, searchResponse ]
 }


 //////////////////////////////////////////////////////////////////////////////
 // Facet Rendering
 //////////////////////////////////////////////////////////////////////////////

 function toggleFacetValueSelection (name, value) {
   const params = new URLSearchParams(location.search)
   const paramKey = `${name}[]`
   let paramVals = params.getAll(paramKey)

   if (paramVals.includes(value)) {
     paramVals = paramVals.filter(x => x !== value)
   } else {
     paramVals.push(value)
   }
   params.delete(paramKey)
   paramVals.forEach(v => params.append(paramKey, v))

   // Delete any start param.
   params.delete("start")

   updateUrlSearchParams(params)
   search(getSearchParams())
 }


 function MultiCallToActionFacetEl () {
   /* Return a SearchFacet variant to serve as a multi-collection-search
      call-to-action.
    */
   const el = createElement(
     `<search-facet name="" display-name="Additional Collections" collapsed>
        <search-facet-values>
          <search-facet-value value="Search ${indicesDirectory.length} additional collections from {{ site.organization-name }}" doc-count=""></search-facet-value>
        </search-facet-values>
      </search-facet>`
   )

   const facetValueEl = el.querySelector("search-facet-value")
   const nameEl =  facetValueEl.querySelector(".name")
   nameEl.style.overflow = "visible"
   nameEl.style.whiteSpace = "normal"

   // Define the click handler to redirect to the multi-collection page.
   facetValueEl.addEventListener("click", e => {
     e.stopPropagation()
     // Get any current query search param.
     const params = new URLSearchParams(location.search)
     // Set initial search conditions to all available indices / collections.
     for (let indiceTitle of indicesDirectoryTitleIndexMap.keys()) {
       params.append("collection[]", indiceTitle)
     }
     // Do the redirect.
     window.location = `{{ site.baseurl }}/multi-collection-search?${params.toString()}`
   })

   return el
 }


 function renderFacets (aggregations) {
   // Get the facets container element and remove any current childeren.
   const facetsEl = document.getElementById("facets")
   removeChildren(facetsEl)

   // Get the ordered array of facet names.
   let fieldNames = FACETED_FIELD_NAMES

   // If this is the multi-search page, include a collection facet.
   if (IS_MULTI_SEARCH) {
     fieldNames = [ "collection" ].concat(fieldNames)
   }

   // Create the SearchFacets component.
   const searchFacetsEl = new SearchFacets(aggregations, fieldNames)

   // Add a multi-collection-search call-to-action facet if this is a collection-specific
   // search page and there are multiple indices available.
   if (!IS_MULTI_SEARCH && indicesDirectory.length > 1) {
     searchFacetsEl.appendChild(MultiCallToActionFacetEl())
   }

   // Register the facet value click handler.
   searchFacetsEl.addValueClickListener(toggleFacetValueSelection)

   // Append the SearchFacets element to the facets container.
   facetsEl.appendChild(searchFacetsEl)
 }


 function ResultsHeaderElement (numHits, paging) {
   // Calculate the start/end indexes of the current results page.
   const startIdx = paging.start + 1
   const endIdx = startIdx + Math.min(numHits - startIdx, paging.size - 1)

   // Display an error message if the start value is invalid.
   if (endIdx < startIdx) {
     const el = clone(document.getElementById("results-header-error"))
     el.textContent = (
       `Query "start" value (${paging.start}) exceeds the number of total ` +
       `results (${numHits})`
     )
     return el
   }

   const el = clone(document.getElementById("results-header"))

   // Display the document index range.
   el.querySelector(".num-hits").textContent =
     `Showing ${startIdx} - ${endIdx} of ${numHits}`

     // Set the size selector value.
     const sizeEl = el.querySelector('select')
   // If the query specifies a non-standard size, add it as an option.
   if (sizeEl.querySelector(`option[value="${paging.size}"]`) === null) {
     sizeEl.appendChild(
       createElement(
         `<option value="${paging.size}">${paging.size}</option>`
       )
     )
   }
   // Set the value.
   sizeEl.value = paging.size
   // Add a size element change handler.
   sizeEl.addEventListener("change", e => {
     params = new URLSearchParams(location.search)
     params.set("size", sizeEl.value)
     // Reset start to 0 to avoid wierd paging issues.
     params.delete("start")
     updateUrlSearchParams(params)
     search(getSearchParams())
   })

   // Add the paging links.
   const listEl = el.querySelector('ol')
   const pagerListItemTemplate = document.getElementById("results-pager-list-item")

   // Add pagination button click handler.
   listEl.addEventListener("click", e => {
     const el = e.target
     if (el.tagName !== "BUTTON") {
       return
     }
     params = new URLSearchParams(location.search)
     params.set("start", paging.start + parseInt(el.dataset.startDelta))
     updateUrlSearchParams(params)
     search(getSearchParams())
   })

   function PagingLink (html, startDelta, disabled=false) {
     const itemEl = clone(pagerListItemTemplate)
     const buttonEl = itemEl.querySelector("button")
     buttonEl.innerHTML = html
     buttonEl.dataset.startDelta = startDelta
     buttonEl.disabled = disabled
     return itemEl
   }

   const currentPageNum = Math.floor(startIdx / paging.size) + 1
   const maxPageNum = Math.floor(numHits / paging.size) + 1

   // Add the previous page button.
   listEl.appendChild(
     PagingLink("&laquo;&nbsp;prev", -paging.size, currentPageNum === 1)
   )

   // Define the max number of page number button to display on each side
   // of the current page.
   const MAX_NUM_REACHABLE_PAGES = 2

   // Determine whether we're going to show the first and last page buttons.
   const showFirstPageButton = currentPageNum > MAX_NUM_REACHABLE_PAGES + 1
   const showLastPageButton = (
     maxPageNum - currentPageNum > MAX_NUM_REACHABLE_PAGES
   )

   const ellipsisItemElTemplate =
     document.getElementById("results-pager-list-item-ellipsis")

   // Maybe add a first page button.
   if (showFirstPageButton) {
     listEl.appendChild(
       PagingLink("1", -paging.start)
     )
     listEl.appendChild(clone(ellipsisItemElTemplate))
   }

   // Add the adjacent page buttons.
   let pageNumDelta = -MAX_NUM_REACHABLE_PAGES
   while (pageNumDelta <= MAX_NUM_REACHABLE_PAGES) {
     const pageNum = currentPageNum + pageNumDelta
     if (
       pageNum > 0
       && (pageNum !== 1 || !showFirstPageButton)
       && (pageNum !== maxPageNum || !showLastPageButton)
       && pageNum <= maxPageNum
     ) {
       const isCurrentPage = pageNum === currentPageNum
       const pagingLinkEl = PagingLink(
         `${pageNum}`,
         paging.size * pageNum - endIdx,
         isCurrentPage
       )
       // Set the style of the active page.
       if (isCurrentPage) {
         const buttonEl = pagingLinkEl.querySelector("button")
         buttonEl.style.backgroundColor = "#444"
         buttonEl.style.color = "#fff"
       }
       listEl.appendChild(pagingLinkEl)
     }
     pageNumDelta += 1
   }

   // Maybe add a last page button.
   if (showLastPageButton) {
     listEl.appendChild(clone(ellipsisItemElTemplate))
     listEl.appendChild(
       PagingLink(`${maxPageNum}`, numHits - (numHits % paging.size) - startIdx)
     )
   }

   // Add the next page button.
   listEl.appendChild(
     PagingLink("next&nbsp;&raquo;", paging.size, currentPageNum === maxPageNum)
   )

   return el
 }


 //////////////////////////////////////////////////////////////////////////////
 // Search Result Rendering
 //////////////////////////////////////////////////////////////////////////////

 function renderResults (response, paging) {
   // Get the results table and remove any existing children.
   const resultsTableEl = document.getElementById("results")
   const resultsTableBodyEl = resultsTableEl.querySelector("tbody")
   removeChildren(resultsTableBodyEl)

   if (response === null) {
     return
   }

   // Add the results header element.
   const resultsHeaderEl = document.querySelector(".results-header")
   removeChildren(resultsHeaderEl)
   const numHits = response.hits.total.value
   if (numHits > 0) {
     resultsHeaderEl.appendChild(
       ResultsHeaderElement(numHits, paging)
     )
   }

   // Add each result to the results table.
   const resultTemplate = document.getElementById("result")
   const resultDetailsItemTemplate = document.getElementById("result-details-item")
   response.hits.hits.forEach(hit => {
     // Clone the result template element.
     const resultEl = clone(resultTemplate)

     // Set the preview image href and src attributes.
     const imgContainerEl = resultEl.querySelector(".preview-image")
     imgContainerEl.querySelector("a").href = hit._source.url
     imgContainerEl.querySelector("img").src = hit._source.thumbnailContentUrl

     // Set the title href and text.
     const detailsEl = resultEl.querySelector(".details")
     const titleEl = detailsEl.querySelector("a")
     titleEl.href = hit._source.url
     titleEl.textContent = hit._source[DISPLAY_FIELD_NAMES[0]]

     // If this is a multi-search page, add a collection link.
     if (IS_MULTI_SEARCH) {
       const detailsItemEl = clone(resultDetailsItemTemplate)
       detailsItemEl.innerText = "Collection: "
       const aEl = document.createElement("a")
       aEl.href = hit._source.collectionUrl
       aEl.textContent = hit._source.collectionTitle
       detailsItemEl.appendChild(aEl)
       detailsEl.appendChild(detailsItemEl)
     }

     // Add each details field value.
     DISPLAY_FIELD_NAMES.slice(1).forEach(fieldName => {
       const detailsItemEl = clone(resultDetailsItemTemplate)
       const fieldTitle = snakeToTitleCase(fieldName)
       const fieldValue = hit._source[fieldName]
       if (fieldValue !== undefined) {
         detailsItemEl.textContent = `${fieldTitle}: ${fieldValue}`
         detailsEl.appendChild(detailsItemEl)
       }
     })

     // Append the result to the results table.
     resultsTableBodyEl.appendChild(resultEl)
   })
 }

 /* search function */
 async function search (searchParams) {
   const [ paging, response ] = await executeSearch(searchParams)

   // Call renderResults() before we check for a numm response in order to
   // empty the results table in the event of an error.
   renderResults(response, paging)

   if (response === null) {
     document.querySelector("#search-error").innerText =
       "Search failed. Please contact your administrator."
       return
   }

   renderFacets(response.aggregations)
 }

 function getSearchParams () {
   // Wrapper for getUrlSearchParams that also splits the comma-separated "fields" value.
   const params = getUrlSearchParams()
   if (params.has("fields")) {
     params.set("fields", params.get("fields").split(","))
   }
   return params
 }

 // Subscribe an URL_SEARCH_PARAMS_UPDATED topic handler that executes a new search.
 subscribe(TOPICS.URL_SEARCH_PARAMS_UPDATED, () => {
   search(getSearchParams())
 })

 function toggleAdvancedSearchOptionsVisibility () {
   // Show / hide the advanced search options element.
   const wrapperEl = document.getElementById("advanced-search")
   const [ buttonEl, optionsEl ] = wrapperEl.children
   // TODO - use classList.add/remove instead of property assignment.
   if (optionsEl.style.display === "block") {
     wrapperEl.style.border = "none"
     wrapperEl.style.backgroundColor = "transparent"
     optionsEl.style.display = "none"
     buttonEl.innerText = "show advanced options"
   } else {
     wrapperEl.style.border = "solid #ccc 1px"
     wrapperEl.style.borderTop = "none"
     wrapperEl.style.backgroundColor = "#fafafa"
     optionsEl.style.display = "block"
     buttonEl.innerText = "hide advanced options"
   }
   buttonEl.blur()
 }

 function hideAdvancedSearchOptions () {
   // Hide the advanced search options element if visible.
   if (document.querySelector("#advanced-search > div:nth-child(2)")
               .style.display === "block") {
     toggleAdvancedSearchOptionsVisibility()
   }
 }

 function toggleAdvancedSearchFields (e) {
   // "this" is bound to the form element.
   const checked = e.target.checked
   this.querySelectorAll('[name="fields[]"]').forEach(
     el => el.checked = checked
   )
 }

 function searchFormSubmitHandler (e) {
   // Prevent the default submission behavior.
   e.preventDefault()

   // Get the form data.
   const formEl = e.target
   const formData = new FormData(formEl)

   // Get the query string.
   const q = formData.get("q")

   // Get all of the selected field checkbox values.
   const selectedFieldNames = formData.getAll("fields[]")

   // Hack to fix a bug for the demo where a new search using the
   // embeddd input doesn't update the URL.
   const url = new URL(location.href)
   const urlSearchParams = new URLSearchParams(url.search)
   urlSearchParams.set("q", q)

   // Get the number of selected and total fields.
   const numSelectedFields = selectedFieldNames.length
   const numTotalFields = formEl.querySelectorAll('input[name="fields[]"]').length

   // If all or none of the fields are selected, delete the `fields` param,
   // otherwise add it.
   if (numSelectedFields === 0 || numSelectedFields === numTotalFields) {
     urlSearchParams.delete("fields")
   } else {
     urlSearchParams.set("fields", selectedFieldNames.join(","))
   }

   updateUrlSearchParams(urlSearchParams)
   search(getSearchParams())

   hideAdvancedSearchOptions()
 }

 async function initIndicesDirectoryInfo () {
   // Get a list of the indices that are available on this Elasticsearch server
   // and save it to the global indicesDirectory variable.
   indicesDirectory = await getIndicesDirectory()

   // Init the global indice directory title/index maps.
   indicesDirectory.forEach(({ index, title }) => {
     indicesDirectoryIndexTitleMap.set(index, title)
     indicesDirectoryTitleIndexMap.set(title, index)
   })
 }

 document.addEventListener("DOMContentLoaded", async () => {
   await initIndicesDirectoryInfo()

   // Get the search params and do the search.
   const params = getSearchParams()
   search(params)

   // Set the text input value to reflect the current search string and add
   // a listener to submit on Enter.
   const searchForm = document.getElementById("inner-search")
   searchForm.querySelector("[name=q]").value = params.get("q") || ""
   // If fields is specified in the params, set the checkboxes accordingly.
   const fields = params.get("fields")
   if (fields) {
     searchForm.querySelectorAll('[name="fields[]"]').forEach(e => {
       if (!fields.includes(e.value)) {
         e.removeAttribute("checked")
       }
     })
   }

   // Register the search form submit handler.
   const searchEl = document.getElementById("inner-search")
   searchEl.addEventListener("submit", searchFormSubmitHandler)

   // Add advanced search options toggle listener.
   document.querySelector("#advanced-search > button")
                            .addEventListener("click", toggleAdvancedSearchOptionsVisibility)

   // Add advanced search fields toggle listener.
   document.getElementById("include-fields-toggle")
                            .addEventListener("change", toggleAdvancedSearchFields.bind(searchEl))

   window.addEventListener("popstate", () => {
     search(getSearchParams())
   })
 })

</script>
