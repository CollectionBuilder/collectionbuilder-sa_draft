{%- assign fields = site.data.config-search -%}
<script>

const ES_SEARCH_URL = "http://{{ site.elasticsearch-host }}/{{ site.elasticsearch-index }}/_search"

async function doSearch (q) {
  /* Perform the search and return the response, or return null if something
   goes wrong (e.g. server not reachable, response not JSON, etc.)
   */
  let query

  // Build the basic query.
  if (q === "") {
    // Do a match_all query.
    query = {
      query: {
        match_all: {}
      }
    }
  } else {
    // Do a phrase_prefix query.
    query = {
      query: {
        multi_match: {
          query: q,
          type: "phrase_prefix",
          fields: [
            {% assign indexed = fields | where: 'index','true' %}
            {% for f in indexed %}
            "{{ f.field }}",
            {% endfor %}
            "full_text.raw",
          ]
        }
      }
    }
  }

  // Add any aggregations.
  {% assign faceted = fields | where: 'facet','true' %}
  query.aggs = {
    {% for f in faceted %}
    {{ f.field }}: {
      terms: {
        field: "{{ f.field }}.keyword"
      }
    },
    {% endfor %}
  }

  // Specify which document fields we want returned.
  query._source = [
    "objectid",
    {% for f in fields %}
    "{{ f.field }}",
    {% endfor %}
  ]

  let fetchRespons
  try {
    fetchResponse = await fetch(
      ES_SEARCH_URL,
      {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(query)
      }
    )
  } catch (e) {
    return null
  }

  let searchResponse
  // If the content is not JSON, abort, otherwise attempt to decode it.
  if (!fetchResponse.headers.get('Content-Type')
      .startsWith('application/json')) {
    return null
  } else {
    try {
      searchResponse = await fetchResponse.json()
    } catch (e) {
      return null
    }
  }

  if (!fetchResponse.ok) {
    // If it looks like an ES error, print the 'reason' to the console.
    if (searchResponse.error && searchResponse.error.reason) {
      console.error(`Search error: ${searchResponse.error.reason}`)
    }
    return null
  }

  return searchResponse
}


function FacetEl (facet, buckets) {
  const formatFacetName = s =>
        s.replace('_', ' ').replace(/\b[a-z]/g, (x) => x.toUpperCase())

  const el = $(`
  <div style="font-size: 14px; border: solid #ddd 1px; margin-top: 2em;">
    <h1 style="font-size: 1em; background-color: #ddd; padding: .3em; font-weight: bold;">
      ${formatFacetName(facet)}
    </h1>
    ${buckets.map(o => `
      <div style="white-space: nowrap; color: #444; padding: .1em .5em; border-bottom: solid #eee 1px; position: relative;" data-facet="${facet}" data-key="${o.key}">
        <span style="white-space: nowrap; margin-right: 2em;">
          ${o.key.length ? o.key : '&lt;unknown&gt;'}
        </span>
        <span style="position: absolute; right: 1em;">${o.doc_count}</span>
      </div>
    `).join('')}
  </div>
`)

  return el
}

let facetsClickHandler

function renderFacets (aggregations) {
  const facetsEl = $('#facets')
  facetsEl.empty()

  const facets = [{% for f in faceted %}"{{ f.field }}",{% endfor %}]
  for (let facet of facets) {
    if (!aggregations[facet]) {
      continue
    }
    facetsEl.append(FacetEl(facet, aggregations[facet].buckets))
  }

  // Add the click handler is necessary.
  if (!facetsClickHandler) {
    facetsClickHandler = e => {
      const target = e.target.parentElement
      if (target.dataset.hasOwnProperty('facet')) {
        const facetName = target.dataset.facet
        const facetValue = target.dataset.key

        const params = new URLSearchParams(location.search)
        const paramKey = `${facetName}[]`
        let paramVals = params.getAll(paramKey)
        if (paramVals.includes(paramKey)) {
          paramVals.pop(facetValue)
        } else {
          paramVals.push(facetValue)
        }
        params.delete(paramKey)
        paramVals.forEach(v => params.append(paramKey, v))
        location.search = `?${params.toString()}`
      }
    }
    facetsEl.on('click', facetsClickHandler)
  }
}


/* search function */
async function elastic_search (searchParams) {
  const query = searchParams.get('q')
  var resultdiv = $('#results');

  resultdiv.empty();

  const response = await doSearch(query)
  if (response === null) {
    resultdiv.append('Search failed. Please contact your administrator.')
    return
  }

  renderFacets(response.aggregations)

  resultdiv.prepend('<tr><td><h4 class="mt-3">' + response.hits.total.value + ' Result(s) found</h4></td></tr>');
  for (let hit of response.hits.hits) {
    const item = hit._source
    var searchitem =
      '<tr>'+
          '<td class="">' +
            {% assign display = fields | where: 'display','true' %}
            {% for d in display %}
            {% if forloop.first %}
            '<p class="h4"><a href="{{ "/items/" | relative_url }}' + item.objectid + '.html">' + item.{{ fields[0].field }}  + '</a></p>' +
            '<p class="ml-3">' +
              {% else %}
              item.{{ d.field }} + '<br> ' +
              {% endif %}{% endfor %}
            '</p></td>' +
      '</tr>';
    resultdiv.append(searchitem);
  }
}

/* init search box and get query string */
$(document).ready(function() {
  $('input#search').on('keyup', e => {
    elastic_search(e.target.value)
  })
  if (window.location.search) {
    const searchParams = new URLSearchParams(location.search)
    const queryString = searchParams.get('q')
    $('input#search').val(queryString);
    elastic_search(searchParams);
  }
});
</script>
